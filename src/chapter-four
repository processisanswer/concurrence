Lock的使用
AQS原理分析
Condition
CountDownLatch、Semaphore
线程池原理分析
-----
Lock接口
*synchronize与Lock有何区别
--层次上，一个是关键字，一个是类
--使用上，lock具有更大的灵活性，可以控制锁的释放和获取，而
synchronized的锁的释放是被动的，当出现异常或者同步
代码块执行完毕以后，才会释放锁。
--lock可以判断锁的状态，而synchronized无法做到
--lock可以实现公平锁、非公平锁，synchronized只有非公平锁
-----
ReentrantLock 重入锁
基于AQS实现
表示支持重新进入的锁，也就是说，如果当前线程t1通过
调用lock方法获取了锁之后，再次调用lock，是不会再阻塞
去获取锁的，直接增加重试次数就行了。
有两种：公平重入锁和非公平重入锁

ReentrantReadWriteLock 重入读写锁--共享锁，同一时刻可以有多个线程获得锁
         --读锁  写锁，很多场景下读多写少，性能优
读锁与读锁可以共享，读锁与写锁不共享，写锁与写锁不共享
读写锁能够提供比排它锁更好的并发性和吞吐量。
写线程访问时，所有的读线程和其他写线程都会被阻塞。
-----
AQS--AbstractQueuedSynchronizer 提供了FIFO队列
可以看做一个用来实现锁以及其他需要同步功能的框架。
AQS的使用依靠继承来完成，子类通过继承自AQS并实现所
需要的方法来管理同步状态。常见的有ReentrantLock、
CountDownLatch等。
提供了两种功能：
    独占锁、共享锁（仅读与读是共享的）
AQS的内部实现
    同步器依赖内部的一个同步队列（一个FIFO双向队列）来完成
同步装填的管理。当前线程获取同步状态失败时，同步器会将
当前线程以及等待状态等信息构造成一个节点(Node)并将其加入
同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点
中的线程唤醒，使其再次尝试获取同步状态。
    AQS类底层的数据结构是使用双向链表，是队列的一种实现。包括
一个head节点和一个tail节点，分别表示头结点和尾节点，其中头结点
不储存Thread，仅保存next结点的引用。
    静态内部类 Node 双向链表的结构
将未获得锁的线程对象封装成Node对象加入到这个双向链表，加入同步队列
时，为了确保线程安全，使用CAS
有两个算法
compareAndSetTail-->需要传递当前线程认为的尾节点和当前节点，
只有设置成功后，当前节点才正式与之前的尾节点建立关联
compareAndSetHead-->链表
同步队列遵循FIFO,首节点是获取同步状态成功的节点，首节点的线程
在释放同步状态时，将会唤醒后续节点，而后继节点将会在获取同步状态
成功时将自己设置为首节点。
设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够
成功获取到同步状态，因此设置头节点的方法并不需要CAS来保证，它只需要将
首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。
-----------
AQS中，除了本身的链表结构外，还有一个很关键的功能，就是CAS，这个是
保证在多线程并发的情况下保证线程安全的前提下把线程加入到AQS中的方法
    CAS compareAndSwap 乐观锁的实现，对内存中的共享数据做
原子的读写操作
保证线程安全的情况下，把线程加入链表中
基于Unsafe类实现-->Unsafe类是在sun.misc包下，不属于java标准。
但是很多java的基础类库，流行的高性能开发库都是基于Unsafe类开发的
比如Netty/Hadoop/kafka等。Unsafe可认为是Java中留下的后门，提供了
一些低层次操作，如直接访问内存、线程调度等。
----
ReentrantLock的实现原理分析
    重入锁提供了两种实现，一种是非公平的重入锁，
    另一种是公平的重入锁。
    如果在决定时间上，
    先对锁进行获取的请求一定先被满足获得锁，那么这个锁就是公平锁，反之就是
    不公平锁。简单来说，公平锁就是等待时间最长的线程最优先获取锁。
----
LockSupport类
    LockSupport类是java6引入的一个类，提供了基本的线程同步原语。
LockSupport实际上时调用了Unsafe类里的函数，只有两个函数：
    public native void unpark(Thread jthread);
    public native void park(boolean isAbsolute,long time);
unpark函数为线程提供"许可(permit)"
线程调用park函数则等待"许可"
"许可"是一次性的，相当于0/1的开关。
与wait和notify区别
wait和notify并不是很灵活，并且耦合性很高，调用notify必须
确保某个线程处于wait状态，而park/unpark模型真正解耦了线程之间
的同步，先后顺序没有直接关联，同时线程之间不再需要一个Object或者
其他变量来存储状态，不再需要关心对象的存在。
------
总结
---
独占式同步状态获取和释放过程
        获取同步状态时，同步器维护一个同步队列，获取状态
    失败的线程都会被加入到队列中并在队列中进行自旋;移出队列
    (或停止自旋)的条件时前驱结点为头结点且成功获取了同步状态。
    在释放同步状态时，同步器调用tryRelease(int arg)方法释放
    同步状态，然后唤醒头节点的后继节点。
---
公平锁和非公平锁的区别
    锁的公平性是相对于获取锁的顺序而言的。
    公平锁，锁的获取顺序符合请求的绝对时间顺序，FIFO。
    非公平锁，获取锁的时候，会通过CAS进行抢占，公平锁不会。
    公平锁抢占时，加入了[同步队列中当前节点是否有前驱结点]的判断，如果
    该方法返回true，则表示有线程比当前线程更早地请求获取锁，因此
    需要等待前驱线程获取并释放锁之后才能继续获取锁。
---
Condition
    任意一个Java对象，都拥有一组监视器方法——
    wait/notify/notifyAll，这些方法与synchronized同步关键字配合，
    可以实现等待/通知模式
    JUC包提供了Condition来对锁进行精准控制，Condition是一个多线程
    协调通信的工具类，可以让某些线程一起等待某个条件conditon，只有
    满足条件时，线程才会被唤醒。

##########疑问
    唤醒线程的两种方式
        LockSupport.unpark();
        Tread.currentThread().interrupt();?
-----
Condition ；JDK层面的wait和notify











