
1 底层数据结构
    1.7 数组+链表
    1.8 数组+链表+红黑树

2 HashMap中底层用的是单向链表
    class Node{
        int hash;
        K key;
        V value;
        Node<K,V> next;//单向链表
    }

3 HashMap内部成员变量
    Node[];//Node类型的数组

4 计算公式 就是为了确定Node节点的
下标位置  在数组中
    result < 数组的大小
    数%数组大小=[0-(size-1)]
    key.hashCode()就是那个数
所以干脆存储起来
    Node(hash属性：数)

数组的默认初始大小为16，使用移位运算。

5 Node节点的去向是什么，hash(key) hash算法
  Node[] table数组的初始化
  初始化方法
    table.resize();

6 n是2的n次幂
     hash%16=0-15
    ---------------
    (n-1)&hash=0-15
  为了更高的计算效率，用与运算替代取模运算
7 落点位置
    只有是落点是空的，则直接放；
    当前坑位有元素的时候
        if ... key相同，直接覆盖旧的value，返回旧的value
        else if ...key不同，节点是树节点，红黑树节点。
        else ... 1.8是尾插法、1.7是头插法
  不同key的落点可能会落在同一个落点内。
  --------
  如果result结果不相同，落点就不相同。
  这个op1操作数的结果影响了最终的落点。
  32位要想保证最后4位不同
  拆分32位，前16^后16 做一个异或运算，异或操作的结果的散列的可能性做大
  ---hash算法的实现---
  通过这个 异或操作 来 保证 落点的散列性 最大，重复落点可能性最低

  好不容易保证op1操作最后2^n位，散列性最大
  则要保证op2操作数为2^n-1
  所以数组大小必须是2的n次幂，底层代码会进行调整，构造函数中会调整。
8 节点要存储
    链表越来越长，则存取都不方便。
    思路:降低层次，变为红黑树。
    链表变为红黑树的条件：链表长度达到域值--8，这个范围限制为8
    树形结构变为链表结构的条件;链表长度变为阈值--6。
    (6)journey
        数组大小不够用了？
        扩容？什么时候扩容---当前size 大于 负载因子0.75*当前数组大小
        Node节点数量 不能超过16 是小于16个某个值
        16-->32  双倍扩容
        ----负载因子为啥是0.75，还有扩容的确切时机是什么？----

        移动老数组到新数组
        (1)先遍历老数组的大小，以及里边的元素，保证数组的下标位置
        不为空，有元素。
        下标有元素的情况
        a.孤家寡人，位运算取得落点后，直接移动。
        b.下边有元素，并且是链表。循环遍历，使用旧的10000进行与运算 e.hash & oldCap ==0
            hash倒数第5位是0的时候，结果才是0  如果成立，---这时候result和原来【扩容前】的结果是一样的--->这是是原来的位置
            hash倒数第5位是1的时候，结果不等于0，如果成立，---这时候result和原来的结果倒数第5位是1---->最新位置为，原来位置+oldCap。
        c.下边有元素，并且是红黑树，打散，切分

---------地址-----------
        https://github.com/c-rainstorm/blog/blob/tomcat-request-process/interview/阿里二面准备.md#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84























