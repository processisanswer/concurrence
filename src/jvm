1 为什么要学习JVM？
    95年开始，驰骋24年的最核心原因：内存管理
    卡顿、OOM时，就需要学习JVM。

什么是JVM？
    Java虚拟机
    JVM从软件层面屏蔽了
    底层硬件、指令层面的细节
Write Once，Run EveryWhere

C和C++  是编译层面的跨平台

2 三者关系
JVM
JRE 包含JVM
JDK 包含JRE

Java中最小执行单位是 线程
只负责干活。
写的方法都是由线程执行的。
------
javap -v class文件 文件名.txt
    反编译字节码文件
------
线程抢夺CPU时间片
    A、B都来抢夺

3 JVM运行时数据区
    运行一个类的时候，数据的存储和运算的快照
    JDK 1.6
        数据：方法区MethodArea、Heap
        指令：程序计数器、虚拟机栈、本地方法栈


    程序计数器：
        类似计算机的指令寄存器，
        指向当前线程正在执行的字节码的指令或行号；
        线程独享、线程切换保存或恢复现场；
    虚拟机栈：
        一个栈--一种数据结构--用来存储数据的
        --存储什么数据
        存储当前线程运行方法时所需要的数据、指令和返回地址。
        虚拟机栈FILO
            进出进出的单位为栈帧
                一个方法，一个栈帧
                    例如：methodOne:局部变量表、操作数栈、动态链接、出口...
                局部变量表：32位定长slot，如果是64位，则分高低位来放置。slot组
                        8大基本类型
                        引用变量--->指向堆内对象的地址
                                    或者句柄池，通过句柄池再指向堆内对象的地址。
                操作数栈：栈--数据结构--存储数据--
                    你所学会的东西，都是用来推导和验证未知的。
                        局部变量表0 局部变量表1 局部变量表2 ...等等
                动态链接：运行时多态
                        一个接口有多个实现类
                        不同实现类有不同实例
                        实例执行方法时，需要动态解析那个具体的引用。
                    ------
                    动态链接为什么要放在这个栈帧里边呢？
                出口：正常出口、异常出口
                ...虚拟机栈中还有其他东西。

            方法调用的特殊情况--递归
                递归方法中有多少个栈帧，有N个，N是递归次数。
        --问题---
        请问每个栈帧的大小是不是一样的？为什么？
        -----
    本地方法栈：jvm使用的c和c++方法

    方法区：存储类信息，可视为class文件、字符串、常量、静态变量
            类信息、常量(1.7+有变化) JIT数据

    Heap：实例数据
       堆分代
       1.8以前
        新生代、老年代、永久代
        新生代包括 eden s0 s1  比例8:1:1
            所有一般新生的对象都会进入eden
            s0 s1 是存活的对象放置区域。
        新生代、老年代比例是1:2

        永久代 进入方法区
    -----
    如何new一个8M的空间？32位 4B
        new int[8*1024*1024/4]

        先new一个8M的对象，先放入eden区
        理想情况下，不触发大对象，threhold 不触发age TLAB
        再来一个1M对象，eden没空间了，触发ygc/minor gc
            from区放不下8M的对象，则触发担保机制，
            老年代会给from、to区做担保。
            这样8M的对象会被移动至老年代。
            之后1M的对象就放在eden区中。
            ygc后，from区、to区会对调。
        之后再来一个8M的对象，将再次触发ygc，
        1M的对象会被放置到from区
            ygc 会触发复制回收算法，eden区会全部清空。


1.8以后堆分代 新生代 eden 8M from 1M to 1M 共10M
             老年代 共20M
             元空间 Meta Space

垃圾回收
    垃圾回收算法：
         1 引用计数法：为对象添加引用计数器，每当一个点引用它时，计数器
         加1，每当一个引用失效时，计数器减1。任何时刻，计数器
         为0的对象就是不可能再被使用的。
         Python中使用这种算法判定死对象。简单、效率高，难以解决对象
         之间的循环引用问题。
         2 可达性分析算法：Java、C#、Lisp都使用这种算法。
            是通过一系列的成为GC Root的对象作为起点，
            作为一个Set 集合
            向下搜索他们引用的对象，可以生成一棵引用树，
            树的节点视为可达对象，反之视为不可达。

    基于可达性分析的垃圾回收算法种类
        标记清理、标记整理、复制回收、分代回收算法
        新生代使用的是复制回收算法。
    垃圾回收器:实现垃圾回收算法的工具
    什么样的对象能被回收？
        不可达对象会被回收。
        如何不可达：
            GC Roots根对象，如果从一个对象没有达到根对象的路径，
            或者说从根对象开始无法引用到该对象，该对象就是不可达的。
            常见的有 对象超出作用域、对象引用指向了其他对象或者null。

----Spring 的Bean如何被回收的？----
    作为单例，如何让一个单例的Bean存在于整个生命周期？
        对象存放在一个 Map 中，其中map singletonObjects 是用来存放单例对象的。
        map singletonObjects 和 beans (在构造方法中new)都是直接使用关键字 new 创建，
        是强引用 ，满足作为 GC Roots 对象的条件(虚拟机栈(栈帧中的本地变量)中引用的对象)。
        这样创建的对象存在map中和 GC Roots 对象相连，所以不会被回收。

    prototype 用完即回收。
    单例呢？
    GC ROOT
    什么是GC ROOT？什么样的变量和对象可以成为一个GC ROOT？
    JVM中可以作为GC Roots的对象，如下：
        虚拟机栈中引用的对象，准确的说是虚拟机栈中的栈帧。
        方法区中类静态属性引用的对象。
            静态属性是该类型class的属性，不单独属于任何实例，因此
            该属性自然会作为GC roots。只要这个class存在，该引用指向
            的对象也会一直存在。
        方法区中常量引用的对象。
        本地方法栈中JNI（native方法中）引用的对象，触及个人知识盲区。
        不可达对象一定会被回收吗？不是的，执行垃圾回收前JVM会执行
        不可达对象的finalize方法，如果执行完毕之后该对象变为可达，
        则不会回收它，但一个对象的finalize方法只会被执行一次。
        强引用、软引用、弱引用、虚引用
---内存泄漏的怎么做？怎么找出泄漏源？
---FULL GC 5分钟一次，怎么优化？
    性能优化，什么是性能？
    性能衡量的维度是什么？
    为什么要优化？
    追求的是吞吐量，还是最小执行时间？
    要搞清楚性能优化的具体目标是什么？

--Spring Bean 单例和多例
    在Spring容器中Bean的作用域分为singleton、prototype。
    singleton的对象为单例模式，这样的对象在Spring的容器中只维持一个，
    需要的时候可以来取，也就是说这个对象将自己的控制权交给了Spring容器，
    那么他什么时候创建(单例的对象在加载配置文件的时候创建)与销毁取决于Spring容器
    而不是取决于Bean类本身。而prototype类型的对象，并不是完全交给Spring容器进行管理的，
    创建的时候需要Spring容器进行创建，但是销毁的时候并不取决于Spring容器，
    取决于客户端，当客户端访问的时候由Spring创建对象，客户端访问完成后，
    Bean对象处于未引用的状态下，就会被JVM自动回收。
--Spring 创建Bean的顺序
    当这个Bean有依赖的Bean的时候需要先创建其依赖的Bean，
    然后调用该Bean的构造函数创建实例对象，将依赖的Bean注入进来，接下来会得到
    当前实例化的Bean的id，接着可以得到他当前的容器ApplicationContext对象，
    然后是你设置的initMethod方法。
--Spring 销毁Bean的顺序
    同样的和创建bean的时候类似，在销毁Bean之前执行一些自定义的任务也有两种方式，
    可以通过配置destroy-method来设置调用的方法。另一种方式是实现DisposableBean类
    中的destroy()方法。我这里同样只展示下，destroy-method方法。
--Spring bean的几个属性：scope、init-method、destroy-method、depends-on等。

--JVM优化的参数







